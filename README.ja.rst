=====================================
owk - DSL for structured input stream
=====================================

owk は JSON 等それなりの構造を持ったデータのストリームに対して、
awk 的に使えることを目指して作られている DSL/interpreter です。

::

  $ owk 'put "hello world"'
  hello world
  $ seq 5 | owk '{ put : _.1 * 2 }'
  2
  4
  6
  8
  10


言語仕様について
================

- 動的型付。
- lexical scope 。
- 全て式です。何かしらの値を返します。
- データ型は基本的に全て immutable です。
- 変数の再定義は、同一スコープ中ではできません。親スコープの shadowing は可能です。

データ型
--------

String
~~~~~~

文字列です。

::

  s = "hello, owk"
  put "\u3042" # => あ

Number
~~~~~~

数値です。

::

  i = 2
  j = 10.1
  put (i * j) # => 20.2

Bool
~~~~

真偽値です。

owk において `偽` と判定されるのは、 ``false`` と下で解説する ``Undef`` のみです。

::

  t = true
  f = false

Dict
~~~~

ハッシュとか連想配列とも言われるアレです。

キーの文字列に対して、任意のデータを保持できます。

::

  d = { key => "value", key2 => 100 }
  put d.key # => value
  put (d ["key"]) # => value

辞書の更新 (merge) は以下のように行います。

::

  d2 = d { key2 => 200, key3 => "spam" }
  d3 = d2 ["key4", "egg"]

List
~~~~

リストです。任意のデータを格納できます。

::

  L = [1, 2, 3, "4"]
  put (L[0]) # => 1

``List[start, count]`` で slice を取得できます。

::

  L2 = L[1, 2]
  put L2 # => [2, 3]

Tuple
~~~~~

タプルです。任意のデータを格納できます。

リストとの使い分けですが、こちらは主に関数へ複数の値を渡すのに利用されます。

::

  t = (1, 2)

Function
~~~~~~~~

関数です。

``pattern -> { block }`` の形で定義します。
``block`` には複数の式を記述できます。
``pattern ->`` 部分は省略可能で、その場合 ``_ ->`` が補われます。
また、 ``block`` が単一の式のみからなる場合は ``{ }`` を省略することができます。

``|`` で区切ることにより、複数のパターン・ブロックが記述できます。

関数の戻り値は最後の式の値になります。

関数呼び出しは ``func arg`` の形になります。
複数の値を渡したい場合は Tuple を渡すか、カリー化された関数を定義することで代用します。

なお、 owk においては0引数の関数呼び出しはできません。
不要だとしても最低1つは引数を渡してください。

::

  f = { put "hi" }
  f () # => hi

  f2 = _ -> put "hi"
  f2 () # => hi

  f3 = name -> { put("hi,", name) }
  f3 "nakamuray" # => hi, nakamuray

  f4 = (x, y) -> { x * y }
  put (f4(2, 3))

  f5 = x -> y -> { x * y }
  put (f5(2, 3))

  f6 = i -> { i * 2 }
  put (f6 10) # => 20

  f7 = { _ * 2 }
  put (f7 10) # => 20

  f8 = 0 -> { "zero" } | n -> { n }
  put (f8 0) # => zero
  put (f8 100) # => 100

Ref
~~~

参照です。 owk の他のデータ型は全て immutable なので、破壊的変更を行いたい時はこれを使います。

`Ref` を参照したい時は、関数のように呼び出します。
変更には ``:=`` 演算子を利用します。

::

  r = ref 0
  put (r ()) # => 0
  r := 1
  put (r ()) # => 1

Undef
~~~~~

未定義値です。

::

  u = undef


パターンマッチ
--------------

代入および関数適用の際に、パターンマッチが行われます。

パターンには String, Number, Dict, List, Tuple のリテラルと変数が記述できます。

::

  (a, b) = (1, 2)
  [c, [d, e]] = [3, [4, 5]]
  f = (("6", 7) = ("6", 7))
  { key1 => g, key2 => h } = { key1 => 8, key2 => 9 }
  
  ((i, j) -> { put (i, j) }) (10, 11)


Dict のパターンマッチでは、チェックされる値の側に余分なキーがあっても無視されます。

::

  { key1 => k } = { key1 => 12, key3 => 13 }


マッチに失敗した場合、代入なら Undef が返ります。

::

  l = (0 = 1)

関数適用の場合は次のパターン・ブロックを試みます。全てのパターンにマッチしなかった場合は Undef が返ります。

::

  func = 0 -> { 0 } | 1 -> { 1 }
  put (func 1) # => 1
  put (func 2) # =>

演算子
------

以下の演算子が利用できます。大体見たままです。

``-``, ``+``, ``*``, ``/``,
``>``, ``<``, ``>=``, ``<=``,
``==``, ``!=``, ``=~``, ``!~``,
``!``, ``&&``, ``||``, ``:``, ``?``, ``:=``

見たままでないいくつかを説明します。

- ``:``

  Haskell の ``$`` です。左辺に関数、右辺に引数をとります。

  ::

    put : 1 + 1 # => 2
    put (1 + 1) # => 2

- ``?``

  左辺に `Bool` 、右辺に関数を取り、 `Bool` が `真` のとき右辺を実行します。

  ::

    true ? { put "hi" } # => hi
    false ? { put "hi?" }

- ``:=``

  上記 `Ref` の説明参照。


構文
----

owk スクリプトは、上記のデータ型と演算子を組み合わせた式の羅列になります。
式同士はセミコロン、もしくは改行で区切られます。
式中に改行を書きたい場合はバックスラッシュで改行をエスケープできます。

なお、以下の箇所では改行は無視されます。

- Dict, List and Tuple 中の `,` の左右
- 関数定義の区切りの `|` の左右
- 2項演算子の右側

コメントは ``#`` から改行までです。

組み込み関数
------------

TODO: いつか書く。


owk コマンドについて
====================

実行ファイルであるところの ``owk`` コマンドについて説明します。

``owk`` は引数で渡された owk script をまず一度評価し、
最後の式を ``main`` 関数として扱います。
その後標準入力から読み込まれたデータを一つずつ ``main`` 関数に渡していきます。
最後に、もし定義されていれば ``end`` 関数を実行し、終了します。

::

  $ seq 10 | owk 'put "init"; end = { put "end" }; main = input -> { put("[", input.0, "]") }'
  init
  [ 1 ]
  [ 2 ]
  [ 3 ]
  [ 4 ]
  [ 5 ]
  [ 6 ]
  [ 7 ]
  [ 8 ]
  [ 9 ]
  [ 10 ]
  end

入力は、標準では一行毎に読み込まれ、空白文字で分割されて、
行全体がキー ``0``, 分割された値がキー ``1`` から順番に割り振られ、
`Dict` に格納されて渡されます。

``-e`` オプションを指定することで、
入力を読み込まず渡された script を実行するだけの `eval` モードになります。

::

  $ seq 10 | owk -e 'put "hi"'
  hi

``-r`` オプションを指定することで、
入力を畳み込む `reduce (fold)` モードになります。
``-r`` オプションは script 文字列を2つ受け取り、
最初のものを畳み込み関数、2つ目のものを初期値として扱います。
初期値は省略可能で、その場合 `undef` が渡ります。

::

  $ seq 10 | owk -r 'acc -> i -> { acc + i.1 }' 0
  55
  $ seq 10 | owk -r 'acc -> i -> { acc + i.1 }'
  55

また、複数の owk script を渡すことで、それぞれを連結して実行することができます。

::

  $ seq 10 | owk '{ put : _.1 + 1 }' '{ put : _ * 2 }' -r 'acc -> i -> acc + i'
  130

入力をどのようにパースするかは ``-i`` オプションで指定できます。
デフォルトでは行ごとにスペースで分割し、数値もしくは文字列として、
数値をキーにした辞書に格納され、渡ります。

::

  $ echo '1 2 three' | owk '{ put _ }'
  {0 => "1 2 three", 1 => 1, 2 => 2, 3 => "three"}

例えば ``-i json`` と指定することで、 JSON としてパースするようになります。

::

  $ echo '{ "value": 1 } { "value": 2 } { "value": 3 }' | owk -i json -m 'put $.value'
  1 
  2 
  3 

また、出力をどのように変換するかは ``-o`` オプションで指定できます。

::

  $ owk -o json -e 'put { key => "value", key2 => 100 }'
  {"key2":100,"key":"value"}
