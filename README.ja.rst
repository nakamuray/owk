=====================================
owk - DSL for structured input stream
=====================================

owk は JSON 等それなりの構造を持ったデータのストリームに対して、
awk 的に使えることを目指して作られている DSL/interpreter です。

::

  $ owk 'print "hello world"; exit()'
  hello world
  $ seq 5 | owk -m 'print : num $.1 * 2'
  2
  4
  6
  8
  10


言語仕様について
================

- 動的型付。
- lexical scope 。
- 全て式です。何かしらの値を返します。
- データ型は基本的に全て immutable です。
- 変数の再定義は、同一スコープ中ではできません。親スコープの shadowing は可能です。

データ型
--------

String
~~~~~~

文字列です。

::

  s = "hello, owk"
  print "\u3042" # => あ

Number
~~~~~~

数値です。

::

  i = 2
  j = 10.1
  print (i * j) # => 20.2

Bool
~~~~

真偽値です。

owk において `偽` と判定されるのは、 ``false`` と下で解説する ``Undef`` のみです。

::

  t = true
  f = false

Dict
~~~~

ハッシュとか連想配列とも言われるアレです。

キーの文字列に対して、任意のデータを保持できます。

::

  d = { key => "value", key2 => 100 }
  print d.key # => value
  print (d ["key"]) # => value

辞書の更新 (merge) は以下のように行います。

::

  d2 = d { key2 => 200, key3 => "spam" }
  d3 = d2 ["key4", "egg"]

List
~~~~

リストです。任意のデータを格納できます。

::

  L = [1, 2, 3, "4"]
  print (L[0]) # => 1

``List[start, count]`` で slice を取得できます。

::

  L2 = L[1, 2]
  print L2 # => [2, 3]

Function
~~~~~~~~

関数です。

関数の戻り値は最後の式の値になります。

関数呼び出しは ``func arg1, arg2`` の形になります。括弧は不要です。

なお、 owk においては0引数の関数呼び出しはできません。
不要だとしても最低1つは引数を渡してください。

引数は、多ければ無視され、少なければ ``undef`` が入ります。

::

  f = { print "hi" }
  f () # => hi

  f2 = name -> { print "hi,", name }
  f2 "nakamuray" # => hi, nakamuray

  f3 = i -> { i * 2 }
  print (f3 10) # => 20

簡便のため、暗黙の最後の仮引数 ``_`` が定義されます。

::

  f4 = { _ * 2 }
  print (f4 10) # => 20

Ref
~~~

参照です。 owk の他のデータ型は全て immutable なので、破壊的変更を行いたい時はこれを使います。

`Ref` を参照したい時は、関数のように呼び出します。
変更には ``:=`` 演算子を利用します。

::

  r = ref 0
  print (r ()) # => 0
  r := 1
  print (r ()) # => 1

Undef
~~~~~

未定義値です。

::

  u = undef

``()`` としても `Undef` の値を生成できます。
引数を必要としない関数呼び出し等をそれらしく見せるのに利用します。

::

  f = { print "undef!" }
  f ()


演算子
------

以下の演算子が利用できます。大体見たままです。

``-``, ``+``, ``*``, ``/``,
``>``, ``<``, ``>=``, ``<=``,
``==``, ``!=``, ``=~``, ``!~``,
``!``, ``&&``, ``||``, ``:``, ``?``, ``:=``

見たままでないいくつかを説明します。

- ``:``

  Haskell の ``$`` です。左辺に関数、右辺に引数をとります。

  ::

    print : 1 + 1 # => 2
    print (1 + 1) # => 2

- ``?``

  左辺に `Bool` 、右辺に関数を取り、 `Bool` が `真` のとき右辺を実行します。

  ::

    true ? { print "hi" } # => hi
    false ? { print "hi?" }

- ``:=``

  上記 `Ref` の説明参照。


構文
----

owk スクリプトは、上記のデータ型と演算子を組み合わせた式の羅列になります。
式同士はセミコロン、もしくは改行で区切られます。
式中に改行を書きたい場合はバックスラッシュで改行をエスケープできます。

コメントは ``#`` から改行までです。

組み込み関数
------------

TODO: いつか書く。


owk コマンドについて
====================

実行ファイルであるところの ``owk`` コマンドについて説明します。

``owk`` は引数で渡された owk script をまず一度評価し、
その後標準入力から読み込まれたデータを一つずつ ``main`` 関数に渡していきます。
最後に、もし定義されていれば ``end`` 関数を実行し、終了します。

::

  $ seq 10 | owk 'print "init"; main = input -> { print "[", input.0, "]" }; end = { print "end" }'
  init
  [ 1 ]
  [ 2 ]
  [ 3 ]
  [ 4 ]
  [ 5 ]
  [ 6 ]
  [ 7 ]
  [ 8 ]
  [ 9 ]
  [ 10 ]
  end

``-m`` オプションを指定することで、 ``main`` の中身をいきなり記述できます。
その際入力は変数 ``$`` に格納されます。

::

  $ seq 10 | owk -m 'print "[", $.0, "]"'
  [ 1 ]
  [ 2 ]
  [ 3 ]
  [ 4 ]
  [ 5 ]
  [ 6 ]
  [ 7 ]
  [ 8 ]
  [ 9 ]
  [ 10 ]

入力は、標準では一行毎に読み込まれ、空白文字で分割されて、
行全体がキー ``0``, 分割された値がキー ``1`` から順番に割り振られ、
`Dict` に格納されて渡されます。

入力をどのようにパースするかは ``-i`` オプションで指定できます。

::

  $ echo '{ "value": 1 } { "value": 2 } { "value": 3 }' | owk -i json -m 'print $.value'
  1 
  2 
  3 

また、出力をどのように変換するかは ``-o`` オプションで指定できます。

::

  $ owk -o json 'print { key => "value", key2 => 100 }; exit()'
  {"key2":100,"key":"value"}
